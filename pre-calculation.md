# Методы предподсчёта и меморизации

Рассмотрим проблему и пути её решения на примере многократного вычисления чисел Фибоначчи. Как известно,
числе Фибоначчи определяются рекурсивно:

$F(n) = F(n - 1) + F(n - 2), F(1) = 1, F(0) = 0$

Напишем вычисляющую их функцию:

``` c++
int fib(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```

Этот метод вычисления n-го числа Фибоначчи имеет экспоненциальную вычислительную сложность. И при уже n = 45
работает очень долго. Если же числа Фибоначчи требуется вычислять многократно, то этот способ становится неприемлемым.

Функцию `fib()` можно улучшить посредством _меморизации_. Для этого заведём внутри функции статический массив, в котором будем сохранять уже посчитанные значения `F(n)`.

``` c++
const int MAX_FIBS = 100;

long long fib(int n) {
  static long long fibs[MAX_FIBS];

  if (n == 0) {
    return 0;
  } else if (n == 1) {
    return 1;
  } else if (fibs[n] > 0) {
    return fibs[n];
  } else {
    fibs[n] = fib(n - 1) + fib(n - 2);
    return fibs[n];
  }
}
```

Эксперимент для F(45) показывает, что значение вычисляется довольно эффективно. Однако, есть один минус. Время
вычисления зависит от того, для каких значений эта функция уже вызывалась. Время вычисления можно сделать предсказуемым, если сначала посчитать все значения для чисел Фибоначии в заданном диапазоне, а затем выдавать
их за постоянное время.

``` c++
const int MAX_FIBS = 100;

long long fib(int n) {
  static long long fibs[MAX_FIBS];
  static bool first_run = true;

  if (first_run) {
    first_run = false;
    fibs[0] = 0;
    fibs[1] = 1;
    for (int i = 2; i <= MAX_FIBS; i++) {
      fibs[i] = fibs[i - 1] + fibs[i - 2];
    }
  }

  return fibs[n];
}
```

Этот метод называет _предподсчёт_ (или предпросчёт).

Если объём предподсчитанных значений невелик, то предельного эффекта от предподсчёта можно достичь, если
написать программу вычисляющую нужные значения, а затем вставить эти значения в основной код.

``` c++
#include <iostream>

using namespace std;

int main() {
  const int MAX_FIBS = 100;
  static long long fibs[MAX_FIBS + 1];
  fibs[0] = 0;
  fibs[1] = 1;
  for (int i = 2; i <= MAX_FIBS; i++) {
    fibs[i] = fibs[i - 1] + fibs[i - 2];
  }
  cout << "{ ";
  cout << fibs[0];
  for (int i = 1; i <= MAX_FIBS; i++) {
    cout << ", " << fibs[i];
  }
  cout << " }" << endl;
  return 0;
}
```

Подведём итог: методы меморизации и предподсчёта применимы, когда диапазон входного параметра целое число, 
ограниченное доступной оперативной памятью с учётом занимаемого места значением функции. Меморизация может
оказаться предпочтительней, если в процессе работы программы обычно требуются не все значения многократно
вычисляемой функции. Наоборот, предпросчёт может дать наибольший эффект, если в программе будут использованы
все значения из заданного диапазона входного параметра. Предельным случаем предпросчёта является отдельное
вычисление значений функции и вставка их в программу в качестве константы.

Наконец, стоит заметить, что имеется более эффективный способ вычисления чисел Фибоначчи, а именно, возведением
в степень специального вида матрицы. Для возведения в степень можно использовать быстрый бинарный алгоритм.
Однако этот подход хорош, когда требуется отдельно взятое значение числа Фибоначчи.

## Задания

1) _Решите методом предподсчёта следующую задачу (источник идеи: одна из книг Мартина Гарднера)._

Как Вы знаете, Вася очень любит математику. И вот недавно Вася, читая очередную книжку
по занимательной математике, наткнулся на весьма занятную головоломку. Суть головоломки
в следующем: Вы должны найти такое десятизначное десятичное число, что в нулевой
позиции этого числа находится количество нулей в этом числе, в первой позиции --
количество единиц и так далее вплоть до девятой позиции (позиции нумеруются от нуля до
девяти слева-направо). Вася сумел найти такое число, но теперь его интересуют все такие
числа, у которых от одного до десяти знаков. Помогите Васе: напишите для него программу,
которая выведет последовательно все решения этой головоломки для чисел с одним
разрядом, затем с двумя разрядами и так далее до десяти разрядов включительно. Каждое
очередное решение должно выводиться в отдельной строке. Если для очередного количества
разрядов найдено несколько решений, то нужно выводить их по возрастанию значений. Если
для очередного количества разрядов решений не найдено, то ничего выводить не нужно.

2) _Напишите программу, многократно вычисляющую суммы элементов подмассива с различными индексами начала и
конца._

Другими словами, Вам дан массив целых чисел длины `n`. И `m` запросов на вычисление суммы элементов массива с индексами от `l` до `r`, где `1 <= l <= r <= n`, а `n` и `m` достаточно велики.

***

(c) 2019, Симоненко Евгений
